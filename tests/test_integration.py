"""Integration / smoke tests against real station output files.

These tests load the CSV outputs regenerated by the pipeline for
the 10 sample stations and validate data-correctness invariants
from P0 and P1:

P0:
  1. No missing-value sentinels leak through — each column is checked
     against its own declared ``missing_values`` from FIELD_RULES
     (after applying scale factors).
  2. Scale factors applied — values fall in physically plausible ranges.
  3. Quality-flagged bad values are NaN, not numbers.

P1:
  4. Categorical and quality columns are absent from Monthly/Yearly.
  5. Field-appropriate aggregation (OC1 max, VIS min, TMP mean) produces
     values consistent with those functions.
"""

from __future__ import annotations

from pathlib import Path

import pandas as pd
import pytest

from noaa_climate_data.constants import (
    FIELD_RULES,
    get_agg_func,
    is_categorical_column,
    is_quality_column,
)

OUTPUT_DIR = Path(__file__).resolve().parent.parent / "output"

# All station directories that have the full five-file set.
STATION_DIRS = sorted(
    d
    for d in OUTPUT_DIR.iterdir()
    if d.is_dir() and (d / "LocationData_Yearly.csv").exists()
)

# Guard: skip the whole module if no station outputs are present.
pytestmark = pytest.mark.skipif(
    len(STATION_DIRS) == 0,
    reason="No station output directories found — run the pipeline first.",
)


# ── Helpers ──────────────────────────────────────────────────────────────


def _sentinel_set_for_column(col: str) -> set[float]:
    """Return the *scaled* sentinel values for *col* from FIELD_RULES.

    For a column like ``VIS__part1`` the function looks up VIS →
    part 1 → ``missing_values`` and applies the part's ``scale`` so that
    the numbers are directly comparable to cleaned CSV values.
    If no rule is found an empty set is returned (nothing to check).
    """
    # Parse "FIELD__partN" or "FIELD__value"  →  (field, part_index)
    parts = col.split("__", 1)
    if len(parts) != 2:
        return set()
    field = parts[0]
    suffix = parts[1]
    # Map suffix → numeric part index used in FIELD_RULES
    if suffix == "value":
        part_idx = 1
    elif suffix.startswith("part"):
        try:
            part_idx = int(suffix[4:])
        except ValueError:
            return set()
    else:
        return set()

    rule = FIELD_RULES.get(field)
    if rule is None:
        return set()
    pinfo = rule.parts.get(part_idx)
    if pinfo is None or not pinfo.missing_values:
        return set()
    scale = pinfo.scale or 1.0
    return {float(v) * scale for v in pinfo.missing_values}


def _value_columns(df: pd.DataFrame) -> list[str]:
    """Return numeric columns that carry measurement data."""
    return [
        c
        for c in df.select_dtypes(include="number").columns
        if not is_quality_column(c)
        and c not in {"ID", "Year", "MonthNum", "Hour", "Day", "YEAR"}
    ]


def _load(station: Path, name: str) -> pd.DataFrame:
    return pd.read_csv(station / f"LocationData_{name}.csv")


# ── P0-1: No sentinel leakage ───────────────────────────────────────────


class TestNoSentinelLeakage:
    """Sentinel values (999, 9999, …) must be NaN, not numbers."""

    @pytest.fixture(params=STATION_DIRS, ids=[d.name for d in STATION_DIRS])
    def station(self, request: pytest.FixtureRequest) -> Path:
        return request.param

    def test_cleaned_no_sentinels(self, station: Path):
        df = _load(station, "Cleaned")
        for col in _value_columns(df):
            sentinels = _sentinel_set_for_column(col)
            if not sentinels:
                continue
            vals = df[col].dropna()
            leaked = vals[vals.isin(sentinels)]
            assert leaked.empty, (
                f"{station.name} Cleaned: {col} has {len(leaked)} sentinel values "
                f"(sentinels={sentinels}, sample: {leaked.head().tolist()})"
            )

    def test_yearly_no_sentinels(self, station: Path):
        df = _load(station, "Yearly")
        for col in _value_columns(df):
            sentinels = _sentinel_set_for_column(col)
            if not sentinels:
                continue
            vals = df[col].dropna()
            leaked = vals[vals.isin(sentinels)]
            assert leaked.empty, (
                f"{station.name} Yearly: {col} has {len(leaked)} sentinel values"
            )


# ── P0-2: Scale factors produce plausible ranges ────────────────────────


class TestPlausibleRanges:
    """Scaled fields must fall in physically reasonable ranges."""

    @pytest.fixture(params=STATION_DIRS, ids=[d.name for d in STATION_DIRS])
    def yearly(self, request: pytest.FixtureRequest) -> pd.DataFrame:
        return _load(request.param, "Yearly")

    def test_temperature_range(self, yearly: pd.DataFrame):
        if "TMP__value" not in yearly.columns:
            pytest.skip("TMP not present")
        vals = yearly["TMP__value"].dropna()
        if vals.empty:
            pytest.skip("No TMP data")
        assert vals.min() >= -90, f"TMP too low: {vals.min()}"
        assert vals.max() <= 60, f"TMP too high: {vals.max()}"

    def test_dew_point_range(self, yearly: pd.DataFrame):
        if "DEW__value" not in yearly.columns:
            pytest.skip("DEW not present")
        vals = yearly["DEW__value"].dropna()
        if vals.empty:
            pytest.skip("No DEW data")
        assert vals.min() >= -90, f"DEW too low: {vals.min()}"
        assert vals.max() <= 50, f"DEW too high: {vals.max()}"

    def test_wind_speed_range(self, yearly: pd.DataFrame):
        if "WND__part4" not in yearly.columns:
            pytest.skip("WND speed not present")
        vals = yearly["WND__part4"].dropna()
        if vals.empty:
            pytest.skip("No WND speed data")
        # Scaled: m/s.  World record gust ~113 m/s; yearly means << 100.
        assert vals.min() >= 0, f"WND speed negative: {vals.min()}"
        assert vals.max() <= 100, f"WND speed too high (not scaled?): {vals.max()}"

    def test_wind_gust_range(self, yearly: pd.DataFrame):
        if "OC1__value" not in yearly.columns:
            pytest.skip("OC1 not present")
        vals = yearly["OC1__value"].dropna()
        if vals.empty:
            pytest.skip("No OC1 data")
        assert vals.min() >= 0, f"OC1 negative: {vals.min()}"
        assert vals.max() <= 120, f"OC1 too high (not scaled?): {vals.max()}"

    def test_altimeter_pressure_range(self, yearly: pd.DataFrame):
        if "MA1__part1" not in yearly.columns:
            pytest.skip("MA1 altimeter not present")
        vals = yearly["MA1__part1"].dropna()
        if vals.empty:
            pytest.skip("No MA1 altimeter data")
        # Reasonable altimeter settings: ~870–1085 hPa.
        assert vals.min() >= 850, f"MA1 altimeter too low: {vals.min()}"
        assert vals.max() <= 1100, f"MA1 altimeter too high (not scaled?): {vals.max()}"

    def test_sea_surface_temp_range(self, yearly: pd.DataFrame):
        if "SA1__value" not in yearly.columns:
            pytest.skip("SA1 not present")
        vals = yearly["SA1__value"].dropna()
        if vals.empty:
            pytest.skip("No SA1 data")
        assert vals.min() >= -5, f"SA1 SST too low: {vals.min()}"
        assert vals.max() <= 45, f"SA1 SST too high (not scaled?): {vals.max()}"


# ── P1-1: Categorical / quality columns excluded from aggregated ─────


class TestCategoricalsExcluded:
    """Monthly and Yearly CSVs must not contain categorical or quality cols."""

    @pytest.fixture(params=STATION_DIRS, ids=[d.name for d in STATION_DIRS])
    def station(self, request: pytest.FixtureRequest) -> Path:
        return request.param

    _KNOWN_CATEGORICALS = {
        "MW1__value",
        "MW2__value",
        "MW3__value",
        "MW4__value",
        "AY1__value",
        "AY2__value",
        "AY1__part1",
        "AY2__part1",
        "AY1__part3",
        "AY2__part3",
        "WND__part3",
        "CIG__part3",
        "CIG__part4",
        "VIS__part3",
        "MD1__part1",
        "GE1__part1",
    }

    def _check_no_categoricals(self, df: pd.DataFrame, label: str):
        present = self._KNOWN_CATEGORICALS & set(df.columns)
        assert not present, f"{label}: categorical columns still present: {present}"

    def _check_no_quality(self, df: pd.DataFrame, label: str):
        quality_cols = [c for c in df.columns if is_quality_column(c)]
        assert not quality_cols, f"{label}: quality columns still present: {quality_cols}"

    def test_yearly_no_categoricals(self, station: Path):
        df = _load(station, "Yearly")
        self._check_no_categoricals(df, f"{station.name}/Yearly")

    def test_yearly_no_quality(self, station: Path):
        df = _load(station, "Yearly")
        self._check_no_quality(df, f"{station.name}/Yearly")

    def test_monthly_no_categoricals(self, station: Path):
        df = _load(station, "Monthly")
        self._check_no_categoricals(df, f"{station.name}/Monthly")

    def test_monthly_no_quality(self, station: Path):
        df = _load(station, "Monthly")
        self._check_no_quality(df, f"{station.name}/Monthly")


# ── P1-2: Aggregation functions are correct ──────────────────────────────


class TestAggregationConsistency:
    """Yearly aggregated values must be consistent with the hourly source.

    We re-aggregate the Hourly CSV ourselves and compare against the
    pipeline's Yearly output to confirm the right function was used.
    """

    @pytest.fixture(params=STATION_DIRS, ids=[d.name for d in STATION_DIRS])
    def station(self, request: pytest.FixtureRequest) -> Path:
        return request.param

    def test_oc1_is_max_not_mean(self, station: Path):
        """OC1 (wind gust) yearly value should equal the max of hourly, not mean."""
        hourly = _load(station, "Hourly")
        yearly = _load(station, "Yearly")
        if "OC1__value" not in hourly.columns or "OC1__value" not in yearly.columns:
            pytest.skip("OC1 not present")
        if yearly["OC1__value"].dropna().empty:
            pytest.skip("No OC1 yearly data")

        for _, yrow in yearly.iterrows():
            yr = yrow["Year"]
            h_vals = hourly.loc[hourly["Year"] == yr, "OC1__value"].dropna()
            if h_vals.empty:
                continue
            expected_max = h_vals.max()
            expected_mean = h_vals.mean()
            actual = yrow["OC1__value"]
            if pd.isna(actual):
                continue
            # The actual should be closer to max than to mean
            # (or equal to max, within float tolerance).
            assert actual == pytest.approx(expected_max, rel=1e-3), (
                f"{station.name} Year={yr}: OC1 yearly={actual:.2f}, "
                f"hourly max={expected_max:.2f}, hourly mean={expected_mean:.2f}"
            )

    def test_vis_is_min_not_mean(self, station: Path):
        """VIS (visibility) yearly value should equal the min of hourly, not mean."""
        hourly = _load(station, "Hourly")
        yearly = _load(station, "Yearly")
        if "VIS__part1" not in hourly.columns or "VIS__part1" not in yearly.columns:
            pytest.skip("VIS not present")
        if yearly["VIS__part1"].dropna().empty:
            pytest.skip("No VIS yearly data")

        for _, yrow in yearly.iterrows():
            yr = yrow["Year"]
            h_vals = hourly.loc[hourly["Year"] == yr, "VIS__part1"].dropna()
            if h_vals.empty:
                continue
            expected_min = h_vals.min()
            actual = yrow["VIS__part1"]
            if pd.isna(actual):
                continue
            assert actual == pytest.approx(expected_min, rel=1e-3), (
                f"{station.name} Year={yr}: VIS yearly={actual:.2f}, "
                f"hourly min={expected_min:.2f}"
            )

    def test_tmp_is_mean(self, station: Path):
        """TMP (temperature) yearly value should equal the mean of hourly."""
        hourly = _load(station, "Hourly")
        yearly = _load(station, "Yearly")
        if "TMP__value" not in hourly.columns or "TMP__value" not in yearly.columns:
            pytest.skip("TMP not present")
        if yearly["TMP__value"].dropna().empty:
            pytest.skip("No TMP yearly data")

        for _, yrow in yearly.iterrows():
            yr = yrow["Year"]
            h_vals = hourly.loc[hourly["Year"] == yr, "TMP__value"].dropna()
            if h_vals.empty:
                continue
            expected_mean = h_vals.mean()
            actual = yrow["TMP__value"]
            if pd.isna(actual):
                continue
            assert actual == pytest.approx(expected_mean, rel=1e-3), (
                f"{station.name} Year={yr}: TMP yearly={actual:.4f}, "
                f"hourly mean={expected_mean:.4f}"
            )
